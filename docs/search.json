[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Rnotebook",
    "section": "",
    "text": "fixedEffects\n\n\n\n\n\n\n\n\n\n\n\n\nMar 29, 2024\n\n\nBrian Leung\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/032924/fixedEffects.html",
    "href": "posts/032924/fixedEffects.html",
    "title": "fixedEffects",
    "section": "",
    "text": "Let’s say we want to quantify the relationship between life expectancy as outcome, and GDP per capita (logged) as predictor. Let’s focus on two countries – Germany and China – across time.\n\ngc &lt;- gapminder %&gt;%\n  filter(country %in% c(\"Germany\", \"China\")) %&gt;%\n  mutate(gdpPercap_log = log(gdpPercap))\n\nLet’s pretend that we forget about the group structure – we treat all data points as if they come from one place. Let’s visualize the relationship between the two variables from the pooled data:\n\n\n\n\n\nThis is equivalent to running a naive regression pooling all data:\n\nm1 &lt;- lm(lifeExp ~ gdpPercap_log, data = gc)\n\n\n\n\n\n\n\nPooled data\n\n\n\n\n(Intercept)\n24.867\n\n\n\n(6.030)\n\n\ngdpPercap_log\n5.079\n\n\n\n(0.705)\n\n\nNum.Obs.\n24\n\n\nR2\n0.703\n\n\n\n\n\n\n\n\n\n\nIt is useful to think about where the variation comes from. The total variation can be broken down into two groups: (1) within-group variation, and (2) between-group variation.\nFor within-group variation, it is just like fitting a regression line for each country separately – each country having its own intercept and slope. Let’s visualize the within-group variation:\n\n\n\n\n\nThis is equivalent to running two separate regressions on China and Germany data respectively:\n\ncdata &lt;- gc %&gt;% filter(country == \"China\")\ngdata &lt;- gc %&gt;% filter(country == \"Germany\")\n\nm2 &lt;- lm(lifeExp ~ gdpPercap_log, data = cdata)\nm3 &lt;- lm(lifeExp ~ gdpPercap_log, data = gdata)\n\n\n\n\n\n\n\nChina data\nGermany data\n\n\n\n\n(Intercept)\n−15.728\n−3.582\n\n\n\n(14.593)\n(8.551)\n\n\ngdpPercap_log\n11.089\n7.826\n\n\n\n(2.075)\n(0.868)\n\n\nNum.Obs.\n12\n12\n\n\nR2\n0.741\n0.890\n\n\n\n\n\n\n\n\n\n\nFor between-group variation, we first compute the group-specific means for the two variable. Then we can draw a line between the two mean points:\n\ngc_mean &lt;- \n  gc %&gt;%\n  group_by(country) %&gt;%\n  summarize(\n    ymin = min(lifeExp), ymax = max(lifeExp),\n    xmin = min(gdpPercap_log), xmax = max(gdpPercap_log),\n    gdpPercap_log = mean(gdpPercap_log),\n    lifeExp = mean(lifeExp)\n  ) %&gt;%\n  mutate(type = \"mean\")\n\ngc_wMean &lt;- gc %&gt;% \n  mutate(type = \"actual\") %&gt;% \n  bind_rows(gc_mean)\n\n\n\n\n\n\nWe can then purge the between-group variation by re-orienting the country observations to its own origin – that is, subtracting the group mean from y-variable and x-variable:\n\ngc_within &lt;- gc %&gt;%\n  group_by(country) %&gt;%\n  mutate(\n    gdpPercap_log_within = gdpPercap_log - mean(gdpPercap_log),\n    lifeExp_within = lifeExp - mean(lifeExp),\n    xmean = mean(gdpPercap_log_within),\n    ymean = mean(lifeExp_within)\n  ) \n\n\n\n\n\n\nLet’s superimpose the two:\n\n\n\n\n\nWe get rid of any between-group difference. What are left are the within-group variations within the specific groups.\nIf we fit a single regression line on the data as a whole after the between-variation is purged:\n\n\n\n\n\nThis is equivalent to running a regression model using the within-variation of x-variable and y-variable. This is further equivalent to running a regression with country-specific intercepts. To see this:\n\nm4 &lt;- lm(lifeExp_within ~ gdpPercap_log_within, data = gc_within)\nm5 &lt;- lm(lifeExp ~ gdpPercap_log + country, data = gc)\n\n\n\n\n\n\n\nWithin variations\nCountry dummy\n\n\n\n\n(Intercept)\n0.000\n−9.882\n\n\n\n(0.799)\n(9.224)\n\n\ngdpPercap_log_within\n10.252\n\n\n\n\n(1.279)\n\n\n\ngdpPercap_log\n\n10.252\n\n\n\n\n(1.309)\n\n\ncountryGermany\n\n−17.586\n\n\n\n\n(4.077)\n\n\nNum.Obs.\n24\n24\n\n\nR2\n0.745\n0.842\n\n\n\n\n\n\n\nThis is what fixed effect is doing – purging between-group variation and using only within-group variation. In other words, let us get rid of the systematic difference between China and Germany, and look at their within-variation together.\nIt is also equivalent to saying: “When the value of the Germany dummy is held constant (i.e., looking at just Germany, or China), what is the relationship between life expectancy and GDP per capita?” This phrasing of fixed effects forces us to think about whether the inclusion of such effects make sense.\n\n\n\nLet’s have a hypothetical treatment where all countries received treatment after the year of 1997. And suppose we run a two-way fixed effects model, controlling for year and country fixed effects, while attempting to estimate the treatment effects:\n\ngc_wTreat &lt;- gc %&gt;%\n  mutate(treat = as.numeric(year &gt; 1997)) %&gt;%\n  mutate(year = factor(year))\n\nm6 &lt;- lm(lifeExp ~ treat + country + year, data = gc_wTreat)\n\n\n\n\n\n\n\n''Treatment effects'' w/ TWFE\n\n\n\n\n(Intercept)\n49.920\n\n\n\n(3.625)\n\n\ntreat\n20.433\n\n\n\n(4.925)\n\n\nNum.Obs.\n24\n\n\nR2\n0.875\n\n\n\n\n\n\n\nIt seems like the treatment is positive and highly statistically significant!\nBut if you look at the underlying estimated coefficients, the fixed effect for year 2007 has actually not estimated (i.e., NA):\n\ntidy(m6)\n\n# A tibble: 14 × 5\n   term           estimate std.error statistic       p.value\n   &lt;chr&gt;             &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;         &lt;dbl&gt;\n 1 (Intercept)      49.9        3.62    13.8    0.0000000279\n 2 treat            20.4        4.92     4.15   0.00162     \n 3 countryGermany   11.7        2.01     5.80   0.000119    \n 4 year1957          4.07       4.92     0.827  0.426       \n 5 year1962          1.65       4.92     0.335  0.744       \n 6 year1967          8.84       4.92     1.80   0.100       \n 7 year1972         11.3        4.92     2.30   0.0423      \n 8 year1977         12.5        4.92     2.53   0.0277      \n 9 year1982         13.9        4.92     2.82   0.0165      \n10 year1987         15.3        4.92     3.11   0.00995     \n11 year1992         16.6        4.92     3.38   0.00618     \n12 year1997         18.1        4.92     3.68   0.00361     \n13 year2002         -0.835      4.92    -0.169  0.869       \n14 year2007         NA         NA       NA     NA           \n\n\nThe estimated coefficient for the treatment is actually that for year 2007, if the treatment variable is dropped. To see this:\n\nm7 &lt;- lm(lifeExp ~ country + year, data = gc_wTreat)\ntidy(m7) %&gt;% filter(term == \"year2007\")\n\n# A tibble: 1 × 5\n  term     estimate std.error statistic p.value\n  &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 year2007     20.4      4.92      4.15 0.00162\n\n\nWhich is equivalent to the treatment effect in the previous model\n\ntidy(m6) %&gt;% filter(term == \"treat\")\n\n# A tibble: 1 × 5\n  term  estimate std.error statistic p.value\n  &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 treat     20.4      4.92      4.15 0.00162\n\n\nWhy is it the case? This is because the treatment variable is collinear with some year dummies. Because we define the treatment such that it has value of 1 if year is greater than 1997. In other words, after 1997, all treatment status is 1 for all observations.\nAdding a year fixed effect is equivalent to asking: Holding a particular year constant, say 2002, what is the difference between the treated and non-treated observations in their outcomes? You can’t answer that question because there is no variation in treatment status after 1997!\nThe illusion of having an estimable treatment effect is simply an artifact that R wants to avoid the problem of collinearity and drops one of the year fixed effect (year 2007 in this case). It prioritizes the treatment variable simply because in the model specification the treat term is put in front of the year term.\nTo show this, revert the order of treat and year:\n\nm8 &lt;- lm(lifeExp ~ country + year + treat, data = gc_wTreat)\ntidy(m8) %&gt;% filter(term == \"treat\")\n\n# A tibble: 1 × 5\n  term  estimate std.error statistic p.value\n  &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 treat       NA        NA        NA      NA\n\n\nIn this case, the treatment effect cannot be estimated. This shows the pitfall of blindly relying on R when you estimate models with a lot of fixed effects. Also, if simply changing the order of the terms gives you different results, you’re probably in trouble which is not safe to ignore.\nA better to avoid this problem is using alternative packages, like fixest, that give better warning:\n\ntwfe_m1 &lt;- feols(lifeExp ~ treat + gdpPercap_log | country + year, \n                 data = gc_wTreat)\n\nThe variable 'treat' has been removed because of collinearity (see $collin.var).\n\n\nThe above warning and the action to drop the collinear variable is much more sensible to prevent researchers from drawing wrong conclusion."
  },
  {
    "objectID": "posts/032924/fixedEffects.html#what-are-fixed-effects-exactly",
    "href": "posts/032924/fixedEffects.html#what-are-fixed-effects-exactly",
    "title": "fixedEffects",
    "section": "",
    "text": "Let’s say we want to quantify the relationship between life expectancy as outcome, and GDP per capita (logged) as predictor. Let’s focus on two countries – Germany and China – across time.\n\ngc &lt;- gapminder %&gt;%\n  filter(country %in% c(\"Germany\", \"China\")) %&gt;%\n  mutate(gdpPercap_log = log(gdpPercap))\n\nLet’s pretend that we forget about the group structure – we treat all data points as if they come from one place. Let’s visualize the relationship between the two variables from the pooled data:\n\n\n\n\n\nThis is equivalent to running a naive regression pooling all data:\n\nm1 &lt;- lm(lifeExp ~ gdpPercap_log, data = gc)\n\n\n\n\n\n\n\nPooled data\n\n\n\n\n(Intercept)\n24.867\n\n\n\n(6.030)\n\n\ngdpPercap_log\n5.079\n\n\n\n(0.705)\n\n\nNum.Obs.\n24\n\n\nR2\n0.703\n\n\n\n\n\n\n\n\n\n\nIt is useful to think about where the variation comes from. The total variation can be broken down into two groups: (1) within-group variation, and (2) between-group variation.\nFor within-group variation, it is just like fitting a regression line for each country separately – each country having its own intercept and slope. Let’s visualize the within-group variation:\n\n\n\n\n\nThis is equivalent to running two separate regressions on China and Germany data respectively:\n\ncdata &lt;- gc %&gt;% filter(country == \"China\")\ngdata &lt;- gc %&gt;% filter(country == \"Germany\")\n\nm2 &lt;- lm(lifeExp ~ gdpPercap_log, data = cdata)\nm3 &lt;- lm(lifeExp ~ gdpPercap_log, data = gdata)\n\n\n\n\n\n\n\nChina data\nGermany data\n\n\n\n\n(Intercept)\n−15.728\n−3.582\n\n\n\n(14.593)\n(8.551)\n\n\ngdpPercap_log\n11.089\n7.826\n\n\n\n(2.075)\n(0.868)\n\n\nNum.Obs.\n12\n12\n\n\nR2\n0.741\n0.890\n\n\n\n\n\n\n\n\n\n\nFor between-group variation, we first compute the group-specific means for the two variable. Then we can draw a line between the two mean points:\n\ngc_mean &lt;- \n  gc %&gt;%\n  group_by(country) %&gt;%\n  summarize(\n    ymin = min(lifeExp), ymax = max(lifeExp),\n    xmin = min(gdpPercap_log), xmax = max(gdpPercap_log),\n    gdpPercap_log = mean(gdpPercap_log),\n    lifeExp = mean(lifeExp)\n  ) %&gt;%\n  mutate(type = \"mean\")\n\ngc_wMean &lt;- gc %&gt;% \n  mutate(type = \"actual\") %&gt;% \n  bind_rows(gc_mean)\n\n\n\n\n\n\nWe can then purge the between-group variation by re-orienting the country observations to its own origin – that is, subtracting the group mean from y-variable and x-variable:\n\ngc_within &lt;- gc %&gt;%\n  group_by(country) %&gt;%\n  mutate(\n    gdpPercap_log_within = gdpPercap_log - mean(gdpPercap_log),\n    lifeExp_within = lifeExp - mean(lifeExp),\n    xmean = mean(gdpPercap_log_within),\n    ymean = mean(lifeExp_within)\n  ) \n\n\n\n\n\n\nLet’s superimpose the two:\n\n\n\n\n\nWe get rid of any between-group difference. What are left are the within-group variations within the specific groups.\nIf we fit a single regression line on the data as a whole after the between-variation is purged:\n\n\n\n\n\nThis is equivalent to running a regression model using the within-variation of x-variable and y-variable. This is further equivalent to running a regression with country-specific intercepts. To see this:\n\nm4 &lt;- lm(lifeExp_within ~ gdpPercap_log_within, data = gc_within)\nm5 &lt;- lm(lifeExp ~ gdpPercap_log + country, data = gc)\n\n\n\n\n\n\n\nWithin variations\nCountry dummy\n\n\n\n\n(Intercept)\n0.000\n−9.882\n\n\n\n(0.799)\n(9.224)\n\n\ngdpPercap_log_within\n10.252\n\n\n\n\n(1.279)\n\n\n\ngdpPercap_log\n\n10.252\n\n\n\n\n(1.309)\n\n\ncountryGermany\n\n−17.586\n\n\n\n\n(4.077)\n\n\nNum.Obs.\n24\n24\n\n\nR2\n0.745\n0.842\n\n\n\n\n\n\n\nThis is what fixed effect is doing – purging between-group variation and using only within-group variation. In other words, let us get rid of the systematic difference between China and Germany, and look at their within-variation together.\nIt is also equivalent to saying: “When the value of the Germany dummy is held constant (i.e., looking at just Germany, or China), what is the relationship between life expectancy and GDP per capita?” This phrasing of fixed effects forces us to think about whether the inclusion of such effects make sense.\n\n\n\nLet’s have a hypothetical treatment where all countries received treatment after the year of 1997. And suppose we run a two-way fixed effects model, controlling for year and country fixed effects, while attempting to estimate the treatment effects:\n\ngc_wTreat &lt;- gc %&gt;%\n  mutate(treat = as.numeric(year &gt; 1997)) %&gt;%\n  mutate(year = factor(year))\n\nm6 &lt;- lm(lifeExp ~ treat + country + year, data = gc_wTreat)\n\n\n\n\n\n\n\n''Treatment effects'' w/ TWFE\n\n\n\n\n(Intercept)\n49.920\n\n\n\n(3.625)\n\n\ntreat\n20.433\n\n\n\n(4.925)\n\n\nNum.Obs.\n24\n\n\nR2\n0.875\n\n\n\n\n\n\n\nIt seems like the treatment is positive and highly statistically significant!\nBut if you look at the underlying estimated coefficients, the fixed effect for year 2007 has actually not estimated (i.e., NA):\n\ntidy(m6)\n\n# A tibble: 14 × 5\n   term           estimate std.error statistic       p.value\n   &lt;chr&gt;             &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;         &lt;dbl&gt;\n 1 (Intercept)      49.9        3.62    13.8    0.0000000279\n 2 treat            20.4        4.92     4.15   0.00162     \n 3 countryGermany   11.7        2.01     5.80   0.000119    \n 4 year1957          4.07       4.92     0.827  0.426       \n 5 year1962          1.65       4.92     0.335  0.744       \n 6 year1967          8.84       4.92     1.80   0.100       \n 7 year1972         11.3        4.92     2.30   0.0423      \n 8 year1977         12.5        4.92     2.53   0.0277      \n 9 year1982         13.9        4.92     2.82   0.0165      \n10 year1987         15.3        4.92     3.11   0.00995     \n11 year1992         16.6        4.92     3.38   0.00618     \n12 year1997         18.1        4.92     3.68   0.00361     \n13 year2002         -0.835      4.92    -0.169  0.869       \n14 year2007         NA         NA       NA     NA           \n\n\nThe estimated coefficient for the treatment is actually that for year 2007, if the treatment variable is dropped. To see this:\n\nm7 &lt;- lm(lifeExp ~ country + year, data = gc_wTreat)\ntidy(m7) %&gt;% filter(term == \"year2007\")\n\n# A tibble: 1 × 5\n  term     estimate std.error statistic p.value\n  &lt;chr&gt;       &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 year2007     20.4      4.92      4.15 0.00162\n\n\nWhich is equivalent to the treatment effect in the previous model\n\ntidy(m6) %&gt;% filter(term == \"treat\")\n\n# A tibble: 1 × 5\n  term  estimate std.error statistic p.value\n  &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 treat     20.4      4.92      4.15 0.00162\n\n\nWhy is it the case? This is because the treatment variable is collinear with some year dummies. Because we define the treatment such that it has value of 1 if year is greater than 1997. In other words, after 1997, all treatment status is 1 for all observations.\nAdding a year fixed effect is equivalent to asking: Holding a particular year constant, say 2002, what is the difference between the treated and non-treated observations in their outcomes? You can’t answer that question because there is no variation in treatment status after 1997!\nThe illusion of having an estimable treatment effect is simply an artifact that R wants to avoid the problem of collinearity and drops one of the year fixed effect (year 2007 in this case). It prioritizes the treatment variable simply because in the model specification the treat term is put in front of the year term.\nTo show this, revert the order of treat and year:\n\nm8 &lt;- lm(lifeExp ~ country + year + treat, data = gc_wTreat)\ntidy(m8) %&gt;% filter(term == \"treat\")\n\n# A tibble: 1 × 5\n  term  estimate std.error statistic p.value\n  &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 treat       NA        NA        NA      NA\n\n\nIn this case, the treatment effect cannot be estimated. This shows the pitfall of blindly relying on R when you estimate models with a lot of fixed effects. Also, if simply changing the order of the terms gives you different results, you’re probably in trouble which is not safe to ignore.\nA better to avoid this problem is using alternative packages, like fixest, that give better warning:\n\ntwfe_m1 &lt;- feols(lifeExp ~ treat + gdpPercap_log | country + year, \n                 data = gc_wTreat)\n\nThe variable 'treat' has been removed because of collinearity (see $collin.var).\n\n\nThe above warning and the action to drop the collinear variable is much more sensible to prevent researchers from drawing wrong conclusion."
  },
  {
    "objectID": "posts/032924/fixedEffects.html#time-series-data-from-two-countries",
    "href": "posts/032924/fixedEffects.html#time-series-data-from-two-countries",
    "title": "fixedEffects",
    "section": "Time-series data from two countries",
    "text": "Time-series data from two countries\nLet’s say we want to quantify the relationship between life expectancy as outcome, and GDP per capita (logged) as predictor. Let’s focus on two countries – Germany and China – across time.\n\ngc &lt;- gapminder %&gt;%\n  filter(country %in% c(\"Germany\", \"China\")) %&gt;%\n  mutate(gdpPercap_log = log(gdpPercap))\n\nLet’s pretend that we forget about the group structure – we treat all data points as if they come from one place. Let’s visualize the relationship between the two variables from the pooled data:\n\nggplot(gc, aes(x = gdpPercap_log, y = lifeExp)) +\n  geom_point(aes(shape = country)) +\n  geom_smooth(method = \"lm\", fill = NA) +\n  stat_regline_equation(show.legend = FALSE) +\n  labs(title = \"Total variation\")\n\n\n\n\nIt is useful to think about where the variation comes from. The total variation can be broken down into two groups: (1) within-group variation, and (2) between-group variation.\nFor within-group variation, it is just like fitting a regression line for each country separately – each country having its own intercept and slope. Let’s visualize the within-group variation:\n\nggplot(gc, aes(x = gdpPercap_log, y = lifeExp, color = country)) +\n  geom_point(aes(shape = country)) +\n  geom_smooth(method = \"lm\", fill = NA) +\n  stat_regline_equation(show.legend = FALSE) +\n  labs(title = \"Within-group variation\")"
  }
]